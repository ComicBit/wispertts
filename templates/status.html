{% extends 'base.html' %} {% block styles %}
<style>
  .status-layout {
    display: grid;
    gap: 24px;
  }

  .progress-timeline {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 12px;
  }

  .timeline-step {
    display: grid;
    grid-template-columns: 32px 1fr;
    gap: 12px;
    padding: 14px 16px;
    border-radius: 14px;
    background: white;
    border: 1px solid rgba(15, 23, 42, 0.07);
    transition: border-color 0.2s ease, background 0.2s ease;
  }

  .timeline-step[data-status="active"] {
    background: rgba(91, 75, 255, 0.1);
    border-color: rgba(91, 75, 255, 0.3);
  }

  .timeline-step[data-status="completed"] {
    background: rgba(34, 197, 94, 0.12);
    border-color: rgba(34, 197, 94, 0.24);
  }

  .timeline-icon {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: grid;
    place-items: center;
    font-size: 0.85rem;
    font-weight: 700;
    color: white;
    background: rgba(148, 163, 184, 0.5);
  }

  .timeline-step[data-status="active"] .timeline-icon {
    background: var(--brand);
  }

  .timeline-step[data-status="completed"] .timeline-icon {
    background: #22c55e;
  }

  .timeline-content {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .timeline-title {
    font-weight: 600;
    color: #0f172a;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .timeline-progress {
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--muted);
  }

  .timeline-desc {
    color: var(--muted);
    font-size: 0.9rem;
  }

  .progress-shell {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 18px;
  }

  .progress-track {
    position: relative;
    width: 100%;
    height: 12px;
    border-radius: 999px;
    background: rgba(148, 163, 184, 0.25);
    overflow: hidden;
  }

  .progress-bar {
    position: absolute;
    inset: 0;
    width: 100%;
    border-radius: 999px;
    background: linear-gradient(90deg, var(--brand), #a855f7);
    transform-origin: left center;
    transform: scaleX(0.02);
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .progress-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: 600;
    color: #1f2937;
  }

  .status-desc {
    color: var(--muted);
    font-size: 0.95rem;
  }

  .status-badge {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 16px;
    border-radius: 999px;
    font-weight: 600;
    background: rgba(148, 163, 184, 0.16);
    color: #334155;
    margin-bottom: 18px;
  }

  .status-badge.processing {
    background: rgba(91, 75, 255, 0.15);
    color: var(--brand);
  }

  .status-badge.success {
    background: rgba(34, 197, 94, 0.18);
    color: #15803d;
  }

  .status-badge.error {
    background: rgba(239, 68, 68, 0.18);
    color: #b91c1c;
  }

  .result-block {
    display: none;
    flex-direction: column;
    gap: 16px;
  }

  .result-block.active {
    display: flex;
  }

  .result-block pre {
    background: white;
    border-radius: 12px;
    border: 1px solid rgba(15, 23, 42, 0.08);
    padding: 18px;
    max-height: 360px;
    overflow-y: auto;
    white-space: pre-wrap;
  }

  .ghost-btn {
    border-radius: 999px;
    border: 1px solid rgba(15, 23, 42, 0.12);
    padding: 10px 18px;
    background: white;
    font-weight: 600;
    color: var(--muted);
    transition: all 0.15s ease;
    display: inline-flex;
    align-items: center;
    gap: 8px;
  }

  .ghost-btn:hover {
    border-color: rgba(15, 23, 42, 0.2);
    color: var(--brand);
  }

  .actions {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
  }
</style>
{% endblock %} {% block content %}
<section class="surface-card status-layout">
  <div>
    <h2 class="mb-3">Your job is running</h2>
    <p class="muted mb-0">
      Keep this page open to watch progress. You can safely head back once it
      finishes.
    </p>
  </div>

  <div>
    <div class="progress-timeline" id="progress-timeline"></div>

    <div class="status-badge" id="status-badge">
      <span class="status-text">Getting things ready…</span>
    </div>

    <div class="progress-shell">
      <div class="progress-track">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
      <div class="progress-meta">
        <span id="progress-stage">Connecting…</span>
        <span id="progress-percent">0%</span>
      </div>
      <p class="status-desc" id="status-intro">
        We are preparing Whisper for your audio.
      </p>
    </div>

    <div class="result-block" id="result-block">
      <div class="actions">
        <a id="download" class="ghost-btn" href="#" download
          >Download transcript</a
        >
        <button type="button" class="ghost-btn" id="copy">
          Copy to clipboard
        </button>
      </div>
      <pre id="result"></pre>
    </div>
  </div>

  <div>
    <a href="/" class="ghost-btn">← Start another transcription</a>
  </div>
</section>
{% endblock %} {% block scripts %}
<script>
  const jobId = "{{ job_id }}";
  const progressBar = document.getElementById('progress-bar');
  const progressStage = document.getElementById('progress-stage');
  const progressPercent = document.getElementById('progress-percent');
  const progressIntro = document.getElementById('status-intro');
  const resultBlock = document.getElementById('result-block');
  const resultEl = document.getElementById('result');
  const downloadEl = document.getElementById('download');
  const copyEl = document.getElementById('copy');
  const statusBadge = document.getElementById('status-badge');
  const statusText = statusBadge.querySelector('.status-text');
  const progressTimeline = document.getElementById('progress-timeline');
  const stageDescriptions = {
    prepare: 'Preparing Whisper and validating settings.',
    load_model: 'Loading the transcription model.',
    convert: 'Optimising audio format for transcription.',
    silence: 'Cleaning silence and trimming pauses.',
    chunk: 'Splitting audio into manageable chunks.',
    diarize: 'Detecting speakers and conversation turns.',
    transcribe: 'Running Whisper to extract text from each chunk.',
    finalize: 'Compiling the final transcript output.',
  };
  const initialMeta = {{ (initial_meta or {}) | tojson }};
  const initialStageText = {{ (initial_stage or 'Processing…') | tojson }};
  const initialDescription = {{ (initial_description or '') | tojson }};
  const initialProgress = {{ (initial_progress or 0) | tojson }};
  const initialStatus = {{ (job_status or 'running') | tojson }};

  function setBadge(message, variant = 'neutral') {
    statusBadge.classList.remove('processing', 'success', 'error');
    if (variant === 'processing') {
      statusBadge.classList.add('processing');
    } else if (variant === 'success') {
      statusBadge.classList.add('success');
    } else if (variant === 'error') {
      statusBadge.classList.add('error');
    }
    statusText.textContent = message;
  }

  function formatStageMetric(item) {
    if (!item) {
      return '';
    }
    if (item.status === 'completed') {
      return 'Done';
    }
    const extra = item.extra || {};
    if (typeof extra.units_total === 'number' && extra.units_total > 0) {
      const done = typeof extra.units_done === 'number' ? extra.units_done : Math.round((item.progress || 0) * extra.units_total);
      return `${done}/${extra.units_total}`;
    }
    if (typeof extra.chunks_total === 'number' && extra.chunks_total > 0) {
      const done = typeof extra.chunks_done === 'number' ? extra.chunks_done : Math.round((item.progress || 0) * extra.chunks_total);
      return `${done}/${extra.chunks_total}`;
    }
    if (typeof item.progress === 'number' && !Number.isNaN(item.progress)) {
      return `${Math.round(item.progress * 100)}%`;
    }
    return '';
  }

  function renderTimeline(timeline) {
    if (!progressTimeline) {
      return;
    }
    if (!Array.isArray(timeline) || timeline.length === 0) {
      progressTimeline.innerHTML = '';
      return;
    }
    progressTimeline.innerHTML = '';
    timeline.forEach((item, index) => {
      const container = document.createElement('div');
      container.className = 'timeline-step';
      container.dataset.status = item.status || 'upcoming';

      const icon = document.createElement('div');
      icon.className = 'timeline-icon';
      icon.textContent = item.status === 'completed' ? '✓' : String(index + 1);

      const content = document.createElement('div');
      content.className = 'timeline-content';

      const title = document.createElement('div');
      title.className = 'timeline-title';
      const label = document.createElement('span');
      label.textContent = item.label || 'Processing';
      title.appendChild(label);

      const metricValue = formatStageMetric(item);
      if (metricValue) {
        const metric = document.createElement('span');
        metric.className = 'timeline-progress';
        metric.textContent = metricValue;
        title.appendChild(metric);
      }

      content.appendChild(title);

      const description = item.description || '';
      if (description) {
        const desc = document.createElement('div');
        desc.className = 'timeline-desc';
        desc.textContent = description;
        content.appendChild(desc);
      }

      container.appendChild(icon);
      container.appendChild(content);
      progressTimeline.appendChild(container);
    });
  }

  function setProgress(value, stageText, description, stageProgress) {
    const pct = Math.max(0, Math.min(100, Math.round(value * 100)));
    progressBar.style.transform = `scaleX(${Math.max(0.02, pct / 100)})`;
    if (typeof stageProgress === 'number') {
      const stagePct = Math.round(stageProgress * 100);
      progressStage.textContent = stagePct ? `${stageText || 'Processing…'} (${stagePct}%)` : (stageText || 'Processing…');
    } else {
      progressStage.textContent = stageText || 'Processing…';
    }
    progressPercent.textContent = `${pct}%`;
    progressIntro.textContent = description || '';
  }

  function applyProgressData(data) {
    const progressValue = typeof data.progress === 'number' ? data.progress : 0;
    const stageText = data.stage || 'Processing…';
    const stageKey = typeof data.stageKey === 'string' ? data.stageKey : null;
    const description = data.description || (stageKey ? stageDescriptions[stageKey] : '') || 'Working through your audio.';
    const stageProgress = typeof data.stageProgress === 'number' ? data.stageProgress : null;

    setProgress(progressValue, stageText, description, stageProgress);
    renderTimeline(Array.isArray(data.timeline) ? data.timeline : []);
  }

  async function poll() {
    try {
      const response = await fetch(`/logs/${jobId}`, {
        headers: {
          'Accept': 'application/json',
        },
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      const data = await response.json();
      const stageText = data.stage || 'Processing…';
      applyProgressData(data);

      if (data.status === 'done') {
        setBadge('Transcript ready!', 'success');
        resultBlock.classList.add('active');
        resultEl.textContent = data.result || '';
        downloadEl.href = `/download/${jobId}`;
        return;
      }

      if (data.status === 'error') {
        setBadge('Something went wrong during processing.', 'error');
        resultBlock.classList.remove('active');
        if (data.error) {
          progressIntro.textContent = data.error;
        }
        return;
      }

      setBadge(stageText || 'Processing with Whisper…', 'processing');
      setTimeout(poll, 1000);
    } catch (err) {
      console.error(err);
      setBadge('Connection hiccup. Retrying…', 'error');
      progressIntro.textContent = 'Trying to reconnect to the transcription job…';
      setTimeout(poll, 2000);
    }
  }

  copyEl.addEventListener('click', async () => {
    if (!resultEl.textContent) {
      return;
    }
    try {
      await navigator.clipboard.writeText(resultEl.textContent);
      copyEl.textContent = 'Copied!';
      setTimeout(() => {
        copyEl.textContent = 'Copy to clipboard';
      }, 1600);
    } catch (err) {
      console.error(err);
    }
  });

  const initialStageProgress = initialMeta && typeof initialMeta.stage_progress === 'number' ? initialMeta.stage_progress : null;
  if (initialMeta && Array.isArray(initialMeta.timeline)) {
    renderTimeline(initialMeta.timeline);
  }
  const resolvedInitialDescription = initialDescription || (initialMeta && typeof initialMeta.stage_key === 'string' ? stageDescriptions[initialMeta.stage_key] : '') || 'Preparing Whisper and validating settings.';
  const resolvedInitialProgress = typeof initialProgress === 'number' ? initialProgress : 0;

  setProgress(resolvedInitialProgress, initialStageText, resolvedInitialDescription, initialStageProgress);

  if (initialStatus === 'done') {
    setBadge('Transcript ready!', 'success');
  } else if (initialStatus === 'error') {
    setBadge('Something went wrong during processing.', 'error');
  } else {
    setBadge(initialStageText || 'Processing with Whisper…', 'processing');
  }
  poll();
</script>
{% endblock %}
